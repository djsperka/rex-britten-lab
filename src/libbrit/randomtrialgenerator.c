#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "randomtrialgenerator.h"
#ifndef linux
#include "ivunif.h"
#define RANDINTERVAL(a, b) ivunif(a, b)
#else
#define RANDINTERVAL(a, b) randinterval(a, b)
#endif

/* local definition of rtg_priv struct. Clients cannot see this */

struct rtg_priv
{
	int *tally;			/* current total tally for each type index */
	int *block;			/* tally for current block (same size as tally) */ 
	int ntypes;			/* number of types */
	int blocksize;		/* block size (Not the size of block array!)*/
	int ntotal;			/* total number of trials of each type */
	int *candidates;	/* array of candidate indices, used in next() */
	int ncandidates;	/* number of candidates used in candidates[] */
	int *list;			/* list generated by list() when in list mode */
	int maxlist;		/* the size of the list[] array */
	int nlist;			/* the number of indices in list[] after a call to list() */
};

/* Static local function declarations */
static int next(RTGenerator *prtgen);
static int mark(RTGenerator *prtgen, int index);
static int marklist(RTGenerator *prtgen, int nlist, int *plist);
static void reset(RTGenerator *prtgen);
static int count(RTGenerator *prtgen, int index);
static void check_block(RTGenerator *prtgen);
static int get_candidate_list(RTGenerator *prtgen);
static int get_default_candidate_list(RTGenerator *prtgen);
static int check_tally(RTGenerator *prtgen);
static int always_empty(RTGenerator *prtgen, int **plist);
static int tlist(RTGenerator *prtgen, int **plist);

#ifdef linux
static int randinterval(int a, int b)
{
	int ir = rand();
	float r = (float)ir/((float)RAND_MAX+1);
	int i= a + (int)(r*(b-a+1));
	/*printf("randinterval(%d, %d)=%d ir=%d RAND_MAX=%d r=%f\n", a, b, i, ir, RAND_MAX, r);*/
	return i;
}
#endif

/* public functions */

RTGenerator *rtg_create(int ntypes, int ntotal, int blocksize)
{
	RTGenerator *prtgen = NULL;
	
	/* check for valid inputs */
	if (ntypes > 0 && ntotal > 0 && blocksize > 0 && ntotal%blocksize==0)
	{
		prtgen = malloc(sizeof(RTGenerator));
		if (prtgen)
		{
			memset(prtgen, 0, sizeof(RTGenerator));
			prtgen->priv = (struct rtg_priv *)malloc(sizeof(struct rtg_priv));
			if (!prtgen->priv)
			{
				rtg_destroy(prtgen);
				prtgen = NULL;
			}
			else
			{
				prtgen->priv->ntypes = ntypes;
				prtgen->priv->blocksize = blocksize;
				prtgen->priv->ntotal = ntotal;
				prtgen->priv->tally = (int *)calloc(ntypes, sizeof(int));
				prtgen->priv->block = (int *)calloc(ntypes, sizeof(int));
				prtgen->priv->candidates = (int *)calloc(ntypes*blocksize, sizeof(int));
				prtgen->priv->list = (int *)NULL;
				prtgen->priv->maxlist = 0;
				prtgen->priv->nlist = 0;
				prtgen->next = next;
				prtgen->mark = mark;
				prtgen->reset = reset;
				prtgen->count = count;
				prtgen->list = always_empty;
				prtgen->marklist = marklist;
				if (!prtgen->priv->tally || !prtgen->priv->block || !prtgen->priv->candidates)
				{
					rtg_destroy(prtgen);
					prtgen = NULL;
				}
				else
				{
					reset(prtgen);
				}
			}
		}
	}
	return prtgen;
}

RTGenerator *rtlistg_create(int ntypes, int ntotal, int blocksize, int listsize)
{
	RTGenerator *prtgen = NULL;
	if (listsize < ntypes*blocksize)
	{
		prtgen = rtg_create(ntypes, ntotal, blocksize);
		if (prtgen && listsize>0)
		{
			prtgen->priv->maxlist = listsize;
			prtgen->priv->nlist = 0;
			prtgen->priv->list = (int *)calloc(listsize, sizeof(int));
			prtgen->list = tlist;
			if (!prtgen->priv->list)
			{
				rtg_destroy(prtgen);
				prtgen = NULL;
			}
		}
	}
	return prtgen;
}

void rtg_destroy(RTGenerator *prtgen)
{
	if (prtgen)
	{
		if (prtgen->priv)
		{
			if (prtgen->priv->tally) free(prtgen->priv->tally);
			if (prtgen->priv->block) free(prtgen->priv->block);
			if (prtgen->priv->candidates) free(prtgen->priv->candidates);
			if (prtgen->priv->list) free(prtgen->priv->list);
			free(prtgen->priv);
		}
		free(prtgen);
	}
	return;
}

void rtg_status(RTGenerator *prtgen)
{
	int i;
	printf("RTGenerator status: ntypes=%d blocksize=%d ntotal=%d\n", prtgen->priv->ntypes, prtgen->priv->blocksize, prtgen->priv->ntotal);
	for (i=0; i<prtgen->priv->ntypes; i++)
	{
		printf("%3d\t%3d\t%3d\n", i, prtgen->priv->block[i], prtgen->priv->tally[i]);
	}
	return;
}

static int next(RTGenerator *prtgen)
{
	int index = -1;
	if (!prtgen) return -1;
	if (get_candidate_list(prtgen) > 0)
	{
		/*
		 * Generate a random number in [0, ncandidates). The type returned
		 * is the value of candidates[random].
		 */
		index = prtgen->priv->candidates[RANDINTERVAL(0, prtgen->priv->ncandidates-1)];
	}
	return index;
}

static int tlist(RTGenerator *prtgen, int **plist)
{
	int i, j, k, irand;

	/*
	 * This can be called only if rtlistg_create was called initially.
	 */

	*plist = NULL;
	prtgen->priv->nlist = 0;
	if (!prtgen->priv->list) return -1;


	if (get_candidate_list(prtgen) > 0)
	{
		/*
		 * Now we make selections from the candidate list, removing each selection from the
		 * list as it is made.
		 */

		for (i=0; i<prtgen->priv->maxlist && prtgen->priv->ncandidates > 0; i++)
		{
			irand = RANDINTERVAL(0, prtgen->priv->ncandidates-1);
			prtgen->priv->list[prtgen->priv->nlist++] = prtgen->priv->candidates[irand];

			/*
			 * Remove candidate at candidates[irand] from the candidates list.
			 */

			for (j=irand+1; j<prtgen->priv->ncandidates; j++)
			{
				prtgen->priv->candidates[j-1] = prtgen->priv->candidates[j];
			}
			prtgen->priv->ncandidates--;
		}

		/*
		 * If the list is full we're done. If the list is not full, however, AND the user has
		 * asked that we pad the list so a full list is always returned, we have to fill
		 * the list in a reasonable way.
		 *
		 * I chose to simplify the problem by imposing a requirement that the listsize be
		 * less than the product of the number of trial types and the blocksize. When that
		 * is the case, we can simply things by using a list consisting of each index.
		 */

		if (prtgen->priv->nlist < prtgen->priv->maxlist)
		{
			get_default_candidate_list(prtgen);

			for (j=prtgen->priv->nlist; j<prtgen->priv->maxlist; j++)
			{
				irand = RANDINTERVAL(0, prtgen->priv->ncandidates-1);
				prtgen->priv->list[prtgen->priv->nlist++] = prtgen->priv->candidates[irand];

				/*
				 * Remove candidate at candidates[irand] from the candidates list.
				 */

				for (k=irand+1; k<prtgen->priv->ncandidates; k++)
				{
					prtgen->priv->candidates[k-1] = prtgen->priv->candidates[k];
				}
				prtgen->priv->ncandidates--;
			}
		}
	}

	if (prtgen->priv->nlist > 0)
	{
		*plist = prtgen->priv->list;
	}

	return prtgen->priv->nlist;
}


/*
 * get_candidate_list
 *
 * Generates a list of candidates for selection.
 * Sets the value priv->ncandidates and fills the candidates[] array.
 * Returns the number of candidates.
 * Called internally - cannot be called by clients.
 */

static int get_candidate_list(RTGenerator *prtgen)
{
	int i, j;
	prtgen->priv->ncandidates = 0;
	if (check_tally(prtgen) == 0)
	{
		/* Generate candidate list */
		for (i=0; i<prtgen->priv->ntypes; i++)
		{
			for (j=prtgen->priv->block[i]; j<prtgen->priv->blocksize; j++)
			{
				prtgen->priv->candidates[prtgen->priv->ncandidates++] = i;
			}
		}
	}
	return prtgen->priv->ncandidates;
}

/*
 * get_default_candidate_list
 *
 * Generates a default list of candidates for selection.
 * The default list is just a single listing of all possible types {0, 1, ..., prtgen->priv->ntypes-1}.
 * Sets the value of priv->ncandidates and returns that value.
 * Called internally - cannot be called by clients.
 */

static int get_default_candidate_list(RTGenerator *prtgen)
{
	int i;
	prtgen->priv->ncandidates = prtgen->priv->ntypes;
	for (i=0; i<prtgen->priv->ntypes; i++)
	{
		prtgen->priv->candidates[i] = i;
	}
	return prtgen->priv->ncandidates;
}

/*
 * check_tally
 * 
 * Tests whether enough trials of each type have been marked.  
 * Returns 1 (0) if enough trials have (NOT) been marked. 
 * Returns -1 if prtgen is NULL.
 * Called internally - cannot be called by clients. 
 */
 
static int check_tally(RTGenerator *prtgen)
{
	int status=0;
	int i;
	if (!prtgen) return -1;
	for (i=0; i<prtgen->priv->ntypes; i++)
	{
		if (prtgen->priv->tally[i]<prtgen->priv->ntotal) break;
	}
	if (i == prtgen->priv->ntypes)
	{
		status = 1;
	}
	return status;
}


static int mark(RTGenerator *prtgen, int index)
{
	int status = -1;
	if (prtgen && index >= 0 && index < prtgen->priv->ntypes)
	{
		status = ++prtgen->priv->block[index];
		check_block(prtgen);
	}
	return status;
}


static int marklist(RTGenerator *prtgen, int nlist, int *plist)
{
	int status = -1;
	int i;
	if (prtgen && nlist>=0 && plist)
	{
		for (i=0; i<nlist; i++)
		{
			status = mark(prtgen, plist[i]);
		}
	}
	return status;
}

/*
 * check_block
 * 
 * Tests whether the current block is filled. If it is, update tally[] and 
 * clear the block. Called internally - cannot be called by clients. 
 */
 
static void check_block(RTGenerator *prtgen)
{
	int i;
	if (!prtgen) return;
	for (i=0; i<prtgen->priv->ntypes; i++)
	{
		if (prtgen->priv->block[i]<prtgen->priv->blocksize) break;
	}
	if (i == prtgen->priv->ntypes)
	{
		for (i=0; i<prtgen->priv->ntypes; i++)
		{
			prtgen->priv->tally[i] += prtgen->priv->block[i];
			prtgen->priv->block[i] = 0;
		}
	}
	return;
}



static void reset(RTGenerator *prtgen)
{
	if (prtgen)
	{
		memset(prtgen->priv->tally, 0, sizeof(int)*prtgen->priv->ntypes);
		memset(prtgen->priv->block, 0, sizeof(int)*prtgen->priv->ntypes);
		memset(prtgen->priv->candidates, 0, sizeof(int)*prtgen->priv->ntypes*prtgen->priv->blocksize);
	}
	return;
}
		

static int count(RTGenerator *prtgen, int index)
{
	int c = -1;
	if (prtgen && index>=0 && index<prtgen->priv->ntypes)
	{
		c = prtgen->priv->tally[index] + prtgen->priv->block[index];
	}
	return c;
}

static int always_empty(RTGenerator *prtgen, int **plist)
{
	return 0;
}
